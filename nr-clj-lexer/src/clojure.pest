// clojure.pest
// Copyright 2024 Matti HÃ¤nninen
//
// Licensed under the Apache License, Version 2.0 (the "License"); you may not
// use this file except in compliance with the License. You may obtain a copy of
// the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
// WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
// License for the specific language governing permissions and limitations under
// the License.

COMMENT = @{ comment_prefix ~ comment_char* }
comment_prefix = { ";" | "#!" }
comment_char = { ! NEWLINE ~ ANY}

WHITESPACE = @{
  ( NEWLINE
  | "\u{09}"  // HT horizontal tab
  | "\u{0B}"  // VT vertical tab
  | "\u{0C}"  // FF form feed
  | " "
  | ","
  )+
}

//
// Top-level, forms, and expressions
//

top_level = { SOI ~ form* ~ discard_expr? ~ EOI }

form = { preform* ~ expr }

preform = { meta_expr | discard_expr }

discard_expr = { discard_prefix ~ preform* ~ expr }
discard_prefix = { "#_" }

meta_expr = { meta_prefix ~ form }
meta_prefix = { "^" | "#^" }

expr = {
    symbol
  | keyword
  | string
  | bogus_map
}

//
// String literals
//

string = ${
    "\""
  ~ ( unescaped
    | esc_char
    | esc_octet
    | esc_code_point
    )*
  ~ "\""
}
unescaped = @{ unescaped_char+ }
unescaped_char = {
  ! ( '\u{00}'..'\u{08}'
    | '\u{0E}'..'\u{1F}'
    | "\u{7F}"
    | "\\"
    | "\""
    )
  ~ ANY
}
esc_char = @{ "\\" ~ ( "b" | "t" | "n" | "f" | "r" | "\"" | "\\" ) }
esc_octet = @{
  "\\" ~ ( '0'..'3' ~ '0'..'7'{2}
         | '0'..'7' {1,2} ~ & ( "\"" | "\\" )
         )
}
esc_code_point = @{ "\\u" ~ ASCII_HEX_DIGIT{4} }

//
// Symbols
//

symbol = ${
    namespace ~ "/" ~ qualified_symbol
  | unqualified_symbol
}
namespace = @{
    symbol_first_char
  ~ symbol_char*
  ~ ( ":" ~ symbol_char+ )*
}
unqualified_symbol = @{
    namespace
  | "/" ~ ! ( symbol_char | "/" | ":" )
}
qualified_symbol = @{
    ( "/"* ~ ":"? ~ symbol_char+ )+
  | "/" ~ ! ":"
}
symbol_char = @{ symbol_first_char | ASCII_DIGIT }
symbol_first_char = @{
    ! ( '\u{00}'..'\u{1F}'
      | " " | ","
      | ASCII_DIGIT
      | ":" | "^" | "`" | "~" | "/"
      | "(" | ")" | "[" | "]" | "{" | "}"
      | "\"" | "\\"
      )
  ~ ANY
}

//
// Keywords
//

keyword = ${
    keyword_prefix
  ~ ( namespace ~ "/" ~ qualified_symbol
    | unqualified_symbol
    )
}
keyword_prefix = @{ "::" | ":" }

// Stubs

bogus_map = { "{}" }
